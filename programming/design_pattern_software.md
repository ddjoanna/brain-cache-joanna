# 設計模式

> 設計模式（Design Pattern）是軟體工程中用來解決常見設計問題的通用方案或範本，能幫助開發者提高程式碼的可重用性、可維護性與擴展性。

設計模式主要分為三大類：

- **創建型模式（Creational Patterns）**：處理物件創建相關問題，封裝物件的生成過程。
- **結構型模式（Structural Patterns）**：處理類與物件組合結構，方便系統架構的組織。
- **行為型模式（Behavioral Patterns）**：處理物件間的互動與責任分配。

---

## 創建型設計模式

| 設計模式                    | 特性說明                                                   | 典型應用場景                               |
| --------------------------- | ---------------------------------------------------------- | ------------------------------------------ |
| 單例模式 (Singleton)        | 確保一個類只有一個實例，並提供全局訪問點。                 | 需要唯一實例的配置管理、資料庫連接等。     |
| 工廠方法 (Factory Method)   | 定義一個創建物件的介面，讓子類決定實例化哪個類。           | 需要靈活決定物件類型，避免硬編碼具體類。   |
| 抽象工廠 (Abstract Factory) | 提供一個介面，用於創建相關或相依物件家族，而不指定具體類。 | 需要生成多種相關物件族，且保持介面一致。   |
| 建造者模式 (Builder)        | 將複雜物件的構建過程分解，分步創建不同表示。               | 需要生成複雜物件，且構建過程可變。         |
| 原型模式 (Prototype)        | 透過複製現有物件來創建新物件，避免重複初始化。             | 需要快速複製大量相似物件，且修改部分屬性。 |

---

## 結構型設計模式

| 設計模式               | 特性說明                                                             | 典型應用場景                           |
| ---------------------- | -------------------------------------------------------------------- | -------------------------------------- |
| 適配器模式 (Adapter)   | 將一個類的介面轉換成客戶端期望的另一個介面，使不兼容的類能一起工作。 | 需要整合不兼容的介面或舊系統。         |
| 桥接模式 (Bridge)      | 將抽象與實現分離，使兩者可以獨立變化。                               | 需要在多維度變化中保持系統靈活性。     |
| 組合模式 (Composite)   | 將物件組合成樹形結構表示「整體/部分」層次。                          | 表示樹狀結構，如組織架構、文件系統。   |
| 裝飾器模式 (Decorator) | 在不改變物件自身的情況下動態添加功能。                               | 需要動態擴展物件功能，如 UI 元件裝飾。 |
| 外觀模式 (Facade)      | 為複雜子系統提供簡單統一的介面。                                     | 隱藏系統複雜性，提供簡易操作介面。     |
| 享元模式 (Flyweight)   | 共享細粒度物件以減少記憶體開銷。                                     | 需要大量相似物件共享狀態，如字型渲染。 |
| 代理模式 (Proxy)       | 為其他物件提供代理以控制對它的訪問。                                 | 控制訪問權限、延遲加載、日誌記錄等。   |

---

## 行為型設計模式

| 設計模式                             | 特性說明                                                 | 典型應用場景                               |
| ------------------------------------ | -------------------------------------------------------- | ------------------------------------------ |
| 策略模式 (Strategy)                  | 定義一系列算法，將每個算法封裝起來，使它們可互換。       | 需要根據情況切換算法，如排序策略。         |
| 模板方法 (Template Method)           | 定義操作的骨架，將部分步驟延遲到子類實現。               | 固定流程中變動部分由子類實現，如框架設計。 |
| 觀察者模式 (Observer)                | 對象間一對多依賴，狀態改變時通知所有依賴者。             | 事件通知、消息推送、GUI 事件處理。         |
| 迭代器模式 (Iterator)                | 提供一種方法順序訪問容器內元素，且不暴露內部結構。       | 容器遍歷，如集合類的遍歷。                 |
| 中介者模式 (Mediator)                | 用中介者封裝多個物件間的交互，降低耦合。                 | 多對多交互，避免物件間直接依賴。           |
| 解釋器模式 (Interpreter)             | 定義語言文法，並建立解釋器解析語言句子。                 | 小型語言解析、表達式計算。                 |
| 狀態模式 (State)                     | 物件行為隨狀態改變而改變，將狀態封裝成物件。             | 狀態機實現，如工作流、UI 狀態切換。        |
| 訪問者模式 (Visitor)                 | 將操作封裝成獨立物件，對元素結構新增操作而不改變元素類。 | 需要對物件結構新增功能，避免修改結構。     |
| 命令模式 (Command)                   | 將請求封裝成物件，支持請求排隊、撤銷等。                 | 操作記錄、撤銷、事務處理。                 |
| 責任鏈模式 (Chain of Responsibility) | 多個物件依次處理請求，避免請求發送者與接收者耦合。       | 審批流程、事件傳遞。                       |
| 備忘錄模式 (Memento)                 | 在不破壞封裝性的前提下保存物件狀態，用於恢復。           | 需要撤銷操作、狀態回溯。                   |

---

以上設計模式皆基於物件導向的三大特性（繼承、封裝、多型）來實現，能有效提升軟體系統的靈活性與可維護性[1][4][7]。

---

**參考來源:**

[1] https://blog.csdn.net/technologyleader/article/details/135601443 \
[2] https://www.cnblogs.com/EthanWong/p/16121385.html \
[3] https://hackmd.io/@luster/SJVLkVd9Y \
[4] https://blog.csdn.net/qq_43792385/article/details/120776328 \
[5] https://kuanchungfeng.github.io/posts/design-pattern-learning-guide/ \
[6] https://fanlv.fun/2021/03/25/design-patterns/ \
[7] https://github.com/0voice/qt_interview_reference/blob/main/175%E3%80%8123%20%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F.md \
[8] http://www.itcast.cn/news/20171114/14101725866.shtml

---

[返回目錄](./../README.md)
